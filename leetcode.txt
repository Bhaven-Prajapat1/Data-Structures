
1) Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

CODE----------------------------------------------------------------

class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int val : nums){
            res ^= val;
        }
        return res;
    }
};

2)You are given an integer array nums of size n.

Consider a non-empty subarray from nums that has the maximum possible bitwise AND.

In other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered.
Return the length of the longest such subarray.

The bitwise AND of an array is the bitwise AND of all the numbers in it.

A subarray is a contiguous sequence of elements within an array.


CODE------------------------------------------------

class Solution {
    public int longestSubarray(int[] nums) {
        int maxVal = Integer.MIN_VALUE;
        int maxRange = 0;
        int currRange = 0;

        for(int i = 0; i < nums.length; i++){
            if(nums[i] > maxVal){
                maxVal = nums[i];
                maxRange = 1;
                currRange = 1;
            } else if(nums[i] == maxVal){
                currRange+=1;
            } else{
                currRange = 0;
            }
            maxRange = Math.max(maxRange,currRange);
        }
        return maxRange;
    }
}










50 ) pow(x , n);

class Solution {
public:
    double myPow(double x, int n) {
        long binform = n;
        if(n<0){
            x = 1/x;
            binform = -binform;
        }
        double ans = 1;

        while(binform > 0){
            if( binform % 2 == 1 ){
                ans *= x;
            }
            x *= x;
            binform /= 2;
        }
        return ans;
    }
};